练习 3.40
===========

定义 ``P`` 为 ``(set! x (* x x))`` ，定义 ``Q`` 为 ``(set! x (* x x x))`` ，以下是并行执行 ``P`` 和 ``Q`` 时可能产生的计算序列（ ``?`` 符号表示执行过程被其他操作打断）：

1. ``P`` --> ``Q``

2. ``Q`` --> ``P`` 

3. ``(set! x (* x ?))`` --> ``Q`` --> ``x`` --> ``(set! x (* x x))``

4. ``(set! x (* x ? ?))`` --> ``P`` --> ``x`` --> ``x`` --> ``(set! x (* x x x))``

5. ``(set! x (* x x ?))`` --> ``P`` --> ``x`` --> ``(set! x (* x x x))``

以上计算序列会产生以下结果：

1. ``(set! x (* 10 10))`` => ``x = 100`` => ``(set! x (* 100 100 100))`` => ``x = 1,000,000``

2. ``(set! x (* 10 10 10))`` => ``x = 1,000`` => ``(set! x (* 1000 1000))`` => ``x = 1,000,000``

3. ``(set! x (* 10 ?))`` => ``(set! x (* 10 10 10))`` => ``x = 1,000`` => ``(set! x (* 10 1000))`` => ``x = 10,000``

4. ``(set! x (* 10 ? ?))`` => ``(set! x (* 10 10))`` => ``x = 100`` => ``(set! x (* 10 100 100))`` => ``x = 100,000`` 

5. ``(set! x (* 10 10 ?))`` => ``(set! x (* 10 10))`` => ``x = 100`` => ``(set! x (* 10 10 100))`` => ``x = 10,000``


串行化
----------

如果将串行化之后的过程 ``(s (lambda () (set! x (* x x))))`` 定义为 ``P1`` ， ``(s (lambda () (set! x (* x x x))))`` 定义为 ``P2`` ，那么 ``P1`` 和 ``P2`` 有以下可能的计算序列：

1. ``P1`` --> ``P2``

2. ``P2`` --> ``P1`` 

它们分别计算出以下结果：

1. ``(* 10 10)`` => ``100`` => ``(* 100 100 100)`` => ``1,000,000``

2. ``(* 10 10 10)`` => ``1000`` => ``(* 1000 1000)`` => ``1,000,000``

因为乘法的交换率原则，只要 ``P1`` 和 ``P2`` 的执行步骤不交错的话，那么它们之间的运行先后顺序是没有关系的，这也是加速一些并行操作常用的技巧。
